# 112_타임리프 - 파일 업로드 - 예제로 구현하는 파일 업로드, 다운로드



## 예제로 구현하는 파일 업로드, 다운로드



실제 파일이나 이미지를 업로드, 다운로드 할 때는 몇가지 고려할 점이 있는데, 구체적인 예제로 알아보자.



**요구사항**

* 상품을 관리
  * 상품 이름
  * 첨부파일 하나
  * 이미지 파일 여러 개
* 첨부파일을 업로드 다운로드 할 수 있다.
* 업로드한 이미지를 웹 브라우저에서 확인할 수 있다.



**Item - 상품 도메인**

```java
package hello.upload.domain;

import lombok.Data;
import java.util.List;

@Data
public class Item {
  private Long id;
  private String itemName;
  private UploadFile attachFile;
  private List<UploadFile> imageFiles;
}
```



**ItemRepository - 상품 리포지토리**

```java
package hello.upload.domain;

import org.springframework.stereotype.Repository;
import java.util.HashMap;
import java.util.Map;

@Repository
public class ItemRepository {
  private final Map<Long, Item> store = new HashMap<>();
  private long sequence = 0L;
  
  public Item save(Item item) {
    item.setId(++sequence);
    store.put(item.getId(), item);
    
    return item;
  }
  
  public Item findById(Long id) {
    
    return store.get(id);
  }
}

```



**UploadFile - 업로드 파일 정보 보관**

```java
package hello.upload.domain;

import lombok.Data;

@Data
public class UploadFile {
  private String uploadFileName;
  private String storeFileName;
  public UploadFile(String uploadFileName, String storeFileName) {
    this.uploadFileName = uploadFileName;
    this.storeFileName = storeFileName;
  }
}
```

`uploadFileName` : 고객이 업로드한 파일명

`storeFileName` : 서버 내부에서 관리하는 파일명



고객이 업로드한 파일명으로 서버 내부에 파일으 저장하면 안된다. 왜냐하면 서로 다른 고객이 같은 파일이름을 업로드하는 경우 기존 파일 이름과 충돌이 날 수 있다. 서버에서는 저장할 파일명이 겹치지 않도록 내부에서 관리하는 별도의 파일명이 필요하다.



**FileStore - 파일 저장과 관련된 업무 처리**

```java
package hello.upload.file;

import hello.upload.domain.UploadFile;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.multipart.MultipartFile;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Component
public class FileStore {
  
  @Value("${file.dir}")
  private String fileDir;
  public String getFullPath(String filename) {
    return fileDir + filename;
  }
  
  public List<UploadFile> storeFiles(List<MultipartFile> multipartFiles)
    throws IOException {
    List<UploadFile> storeFileResult = new ArrayList<>();
    
    for (MultipartFile multipartFile : imageFiles) {
      if (!imageFile.isEmpty()) {
        storeFileResult.add(storeFile(multipartFile));
      }
    }
    
    return storeFileResult;
  }
  
  public UploadFile storeFile(MultipartFile multipartFile) throws IOException 
  {
    
    if (multipartFile.isEmpty()) {
      return null;
    }
    
    String originalFilename = multipartFile.getOriginalFilename();
    String storeFileName = createStoreFileName(originalFilename);
    multipartFile.transferTo(new File(getFullPath(storeFileName)));
    
    return new UploadFile(originalFilename, storeFileName);
  }
  
  private String createStoreFileName(String originalFilename) {
    String ext = extractExt(originalFilename);
    String uuid = UUID.randomUUID().toString();
    
    return uuid + "." + ext;
  }
  
  private String extractExt(String originalFilename) {
    int pos = originalFilename.lastIndexOf(".");
    
    return originalFilename.substring(pos + 1);
  }
}
```

멀티파트 파일을 서버에 저장하는 역할을 담당한다.

* `createStoreFileName()` : 서버 내부에서 관리하는 파일명은 유일한 이름을 생성하는 `UUID` 를 사용해서 충돌하지 않도록 한다.
* `extractExt()` : 확장자를 별도로 추출해서 서버 내부에서 관리하는 파일명에도 붙여준다. 예를 들어서 고객이 `a.png` 라는 이름으로 업로드하면 `51041c62-86e4-4274-801d-614a7d994edb.png` 와 같이 저장된다.

